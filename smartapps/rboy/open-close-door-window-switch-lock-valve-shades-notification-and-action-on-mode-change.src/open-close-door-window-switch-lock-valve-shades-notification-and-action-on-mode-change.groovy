/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "01.07.04"
}

/**
* Notify if any doors/windows/switches/lock/values/shades are open or closed on when a routine changes the mode and take actions
*
* Copyright RBoy Apps, redistribution of code is not allowed without permission
*
* 2017-8-1 - (v01.07.04) Consolidate messages to reduce number of messages to one per group
* 2017-6-15 - (v01.07.03) Update for ST firmware bug for valves
* 2017-5-26 - (v01.07.02) Update to ST platform, now separate multiple SMS numbers with a *
* 2017-5-10 - (v01.07.01) Minor fix to text layout
* 2017-5-8 - (v01.07.00) Added ability to check for closed windows/doors/garge doors/locks when mode is changed, fixed bug with closing garage doors and ability for window shades and water valves
* 2016-11-5 - Added ability to check for new app and device versions, fixed an issue withe mode based notifications
* 2016-9-16 - Added support to check for switches left off which should be on
* 2016-9-16 - Patch for broken HREF in ST app 2.2.0
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-7-30 - Added support for delayed actions
* 2016-7-30 - Added support for contact address books notifications
* 2016-6-6 - Fix for Android phones HREF bug
* 2016-6-3 - Fixed list of items to be checked shown on first page
* 2016-6-3 - Added support to notify if any garage doors are left open and option to close them
* 2016-6-3 - Added support to notify if any doors are left unlocked and option to lock them
* 2016-6-2 - Added support to notify if any switches are left on and option to turn them off
* 2016-6-1 - Initial release
*
*/
definition(
    name: "Open/Close Door/Window/Switch/Lock/Valve/Shades Notification and Action on Mode Change",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Notify if there are any doors/window/switches that are open/unlocked and closes/locks them when a mode changes. E.g. when leaving the house the mode changes to away it will notify the user if any doors are left open.",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/OpenDoor.png",
    iconX2Url: "http://smartthings.rboyapps.com/images/OpenDoor.png",
    iconX3Url: "http://smartthings.rboyapps.com/images/OpenDoor.png")

preferences {
    page(name: "mainPage")
    page(name: "modeDoorMonitorPage")
}

private getCheckingDescription(mode) {
    def description = ""

    def devices = [
        			settings."doors${mode}",
        			settings."doorsflip${mode}",
        			settings."garagedoors${mode}",
                   	settings."garagedoorsflip${mode}",
        			settings."locks${mode}",
               	    settings."locksflip${mode}",
               	    settings."switches${mode}",
               	    settings."switchesflip${mode}",
               	    settings."shades${mode}",
               	    settings."shadesflip${mode}",
                   	settings."valves${mode}",
        			settings."valvesflip${mode}",
    			]
    
    for (device in devices) {                   
        description += device ? (description ? "\n  " : "") + device?.join("\n  ") : ""
    }

    if (!description) { // Nothing selected
        description = "No doors/windows selected"
    } else {
        description = "Checking:\n  " + description // Add the header
    }

    return description
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Open/Close Door/Window/Switch/Lock/Valve/Shade Notification and Action on Mode Change v${clientVersion()}", install: true, uninstall: true) {
        section() {
            paragraph "Click on each Mode below to configure notification options and actions for doors/windows/switches/locks/valves/shades. When the hub changes to the selected mode and if any of the selected doors/windows/switches/locks/valves/shades are found open/closed/locked/unlocked, this app will notify you and take actions."
        }

        def modes = location.modes
        if (modes) {
            for (mode in modes) {
                section {
                    // Unlock actions for each mode
                    def hrefParams = [
                        mode: mode as String, 
                        passed: true 
                    ]
                    log.trace "HREF Mode $mode"
                    href(name: "modeDoorMonitor", params: hrefParams, title: "When switching to mode ${mode}", page: "modeDoorMonitorPage", description: getCheckingDescription(mode), required: false)
                }
            }
            
            section("Delay Actions and Notifications") {
                paragraph "Enable this option to allow the routines to complete their actions after a mode change before checking for any open doors/windows/switches. It waits for about a minute or two before checking"
                input name: "delayAction", title: "Delay checking", type: "bool", required: false
            }
        } else {
            section("Error initializing SmartApp") {
                paragraph "No modes found on the Hub! Contact ST support"
            }
        }

        section("General Notification Options") {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                input name: "notify", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
            }
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def modeDoorMonitorPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def mode = ""
    // Get mode from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.mode) {
        mode = params.mode
        log.trace "Passed from main page, using params lookup for mode $mode"
    } else if (atomicState.params) {
        mode = atomicState.params.mode ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for mode $mode"
    } else {
        log.error "Invalid params, no mode found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Mode Door Monitor, mode:$mode, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"modeDoorMonitorPage", title: "Configure notification options when changing to Mode " + (mode ?: ""), uninstall: false, install: false) {
        section("Choose Door(s) and Window(s)") {
            paragraph "Notify if any of these doors or windows are left open/closed when the hub changes to $mode mode"
            input "doors${mode}", "capability.contactSensor", title: "Check for Open doors/windows", required: false, multiple:true
            input "doorsflip${mode}", "capability.contactSensor", title: "Check for Closed doors/windows", required: false, multiple:true
        }

        section("Choose Garage Door(s)") {
            paragraph "Notify if any of these selected garage doors are left open/closed when the hub changes to $mode mode"
            input "garagedoors${mode}", "capability.garageDoorControl", title: "Check for Open garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoors${mode}") {
                input "garagedoorsoff${mode}", "bool", title: "Close them?", required: false
            }
            input "garagedoorsflip${mode}", "capability.garageDoorControl", title: "Check for Closed garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoorsflip${mode}") {
                input "garagedoorsopen${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Lock(s)") {
            paragraph "Notify if any of these selected locks are Unlocked/Locked when the hub changes to $mode mode"
            input "locks${mode}", "capability.lock", title: "Check for Unlocked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locks${mode}") {
                input "locksoff${mode}", "bool", title: "Lock them?", required: false
            }
            input "locksflip${mode}", "capability.lock", title: "Check for Locked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locksflip${mode}") {
                input "locksopen${mode}", "bool", title: "Unlock them?", required: false
            }
        }

        section("Choose Switch(s)") {
            paragraph "Notify if any of these selected switches are On/Off when the hub changes to $mode mode"
            input "switches${mode}", "capability.switch", title: "Check for switches left On", required: false, multiple:true, submitOnChange: true
            if (settings."switches${mode}") {
                input "switchesoff${mode}", "bool", title: "Turn them off?", required: false
            }
            input "switchesflip${mode}", "capability.switch", title: "Check for switches left Off", required: false, multiple:true, submitOnChange: true
            if (settings."switchesflip${mode}") {
                input "switcheson${mode}", "bool", title: "Turn them on?", required: false
            }
        }

        section("Choose Windows Shade/Blind(s)") {
            paragraph "Notify if any of these selected window shades/blinds are Open/Closed when the hub changes to $mode mode"
            input "shades${mode}", "capability.windowShade", title: "Check for shades left Open", required: false, multiple:true, submitOnChange: true
            if (settings."shades${mode}") {
                input "shadesoff${mode}", "bool", title: "Close them?", required: false
            }
            input "shadesflip${mode}", "capability.windowShade", title: "Check for shades left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."shadesflip${mode}") {
                input "shadeson${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Valve(s)") {
            paragraph "Notify if any of these selected valves are Open/Closed when the hub changes to $mode mode"
            input "valves${mode}", "capability.valve", title: "Check for valves left Open", required: false, multiple:true, submitOnChange: true
            if (settings."valves${mode}") {
                input "valvesoff${mode}", "bool", title: "Close them?", required: false
            }
            input "valvesflip${mode}", "capability.valve", title: "Check for valves left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."valvesflip${mode}") {
                input "valveson${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Mode Specific Notification Options") {
            paragraph "Enabling mode specific notifications will override over any general notifications defined on the first page"
            input "modeOverrideNotifications${mode}", "bool", title: "Enable $mode mode specific notifications", required: false,  submitOnChange: true
            if (settings."modeOverrideNotifications${mode}") {
                input("recipients${mode}", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                    input name: "notify${mode}", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                    paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                    input name: "sms${mode}", title: "Send SMS notification to (optional):", type: "phone", required: false
                }
            }
        }
    }
}

def installed()
{
    log.debug "Installed"

    subscribeToEvents()
}

def updated()
{
    log.debug "Updated"

    unsubscribe()
    unschedule()
    subscribeToEvents()
}

def subscribeToEvents() {
    log.trace settings

    state.queuedActions = [] // initialize it
    
    log.trace "Scheduling heartbeat for every 1 minute"
    schedule("* */1 * * * ?", heartBeat) // Schedule the heartbeat

    subscribe(location, "mode", modeChangeHandler)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def heartBeat() {
	log.trace "Heartbeat called, pending actions: $state.queuedActions"
    def unprocessedActions = []
    def actions = []
    
    synchronized(state) {
        if (state.queuedActions == null) { // Initialize it if it doesn't exist
            log.debug "Initializing queued Actions"
            state.queuedActions = [] // initialize it
        }

        actions = state.queuedActions.clone() // make a copy instead of working on original
        //log.warn "BEFORE CLEAR:$state.queuedActions"
        state.queuedActions.clear() // Clear it
        //log.warn "AFTER CLEAR:$state.queuedActions"
        //log.warn "EXECUTE:$actions"
    }

    for (action in actions) {
        //log.trace "Processing:$action"
        def now = now()
        if (now >= action.time) {
            log.trace "Checking state of doors/windows"
            modeChangeHandler()
        } else {
            unprocessedActions.add(action)
            log.trace "Waiting ${(((action.time - now) as Float)/1000).round()} seconds to process deferred action ${action}"
        }
    }

    if (unprocessedActions) { // If anything is pending
        log.trace "Adding unprocessed actions back to queue: $unprocessedActions"
        // Synchronize these lists otherwise we have a race condition
        synchronized(state) {
            state.queuedActions = state.queuedActions + unprocessedActions // Add back any pending actions (since we are adding an array of maps, use + and not << or .add())
            //log.warn "END:$state.queuedActions"
        }
    }
    
    log.trace "Heartbeat actions finished, pending actions: $state.queuedActions"
}

def modeChangeHandler(evt) {
    log.debug "Mode change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking"}"

    // Check if we need a delayed actions
    if (evt && delayAction) {
        log.trace "Delaying checking by 1 minute"
        
        // Synchronize these lists otherwise we have a race condition
        synchronized(state) {
            if (state.queuedActions == null) { // Initialize it if it doesn't exist
                log.debug "Initializing queued Actions"
                state.queuedActions = [] // initialize it
            }

            //state.queuedActions.clear() // DEBUG CLEAR
            //log.warn "QUEUED ACTIONS: $state.queuedActions" // DEBUG

            state.queuedActions = [[time:(now() + (1 * 60 * 1000) as Long)]] // Delay checking by 1 minute (don't add map to the array only keep 1 map in the array, check for latest mode change)

            //state.queuedActions.clear() // DEBUG CLEAR
            log.trace "Queued actions: $state.queuedActions" // DEBUG
        }
        
        return
    }

    def mode = location.mode // This should the new mode

    // Check for open doors/windows left open
    if (settings."doors${mode}") {
        def message = ""
        for (door in settings."doors${mode}") {
            if (door.currentValue("contact") == "open") {
                message += ", $door"
            } else {
                log.debug "$door is currently Closed"
            }
        }

        if(message) {
            message = "These doors were Open when hub was changed to $mode mode" + message

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No doors/windows found to check for open when hub changed to $mode mode"
    }    

    // Check for open doors/windows left closed
    if (settings."doorsflip${mode}") {
        def message = ""
        for (door in settings."doorsflip${mode}") {
            if (door.currentValue("contact") == "closed") {
                message += ", $door"
            } else {
                log.debug "$door is currently Open"
            }
        }

        if(message) {
            message = "These doors were Closed when hub was changed to $mode mode" + message

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No doors/windows found to check for closed when hub changed to $mode mode"
    }    

    // Check for switches left on
    if (settings."switches${mode}") {
        def message = ""
        for (switchs in settings."switches${mode}") {
            if (switchs.currentValue("switch") == "on") {
                message += ", $switchs"
                if (settings."switchesoff${mode}") {
                    switchs.off()
                }
            } else {
                log.debug "$switchs is currently Off"
            }
        }

        if(message) {
            if (settings."switchesoff${mode}") {
                message = "These switches were On when hub was changed to $mode mode, turning them Off" + message
            } else {
                message = "These switches were On when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No switches found to check for on when hub changed to $mode mode"
    }    

    // Check for switches left off
    if (settings."switchesflip${mode}") {
        def message = ""
        for (switchs in settings."switchesflip${mode}") {
            if (switchs.currentValue("switch") == "off") {
                message += ", $switchs"
                if (settings."switcheson${mode}") {
                    switchs.on()
                }
            } else {
                log.debug "$switchs is currently On"
            }
        }

        if(message) {
            if (settings."switcheson${mode}") {
                message = "These switches were Off when hub was changed to $mode mode, turning them On" + message
            } else {
                message = "These switches were Off when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No switches found to check for off when hub changed to $mode mode"
    }    

    // Check for locks left unlocked
    if (settings."locks${mode}") {
        def message = ""
        for (lock in settings."locks${mode}") {
            if (lock.currentValue("lock") == "unlocked") {
                message += ", $lock"
                if (settings."locksoff${mode}") {
                    lock.lock()
                }
            } else {
                log.debug "$lock is currently Locked"
            }
        }

        if(message) {
            if (settings."locksoff${mode}") {
                message = "These locks were Unlocked when hub was changed to $mode mode, Locking them" + message
            } else {
                message = "These locks were Unlocked when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No locks found to check for unlocked when hub changed to $mode mode"
    }    

    // Check for locks left locked
    if (settings."locksflip${mode}") {
        def message = ""
        for (lock in settings."locksflip${mode}") {
            if (lock.currentValue("lock") == "locked") {
                message += ", $lock"
                if (settings."locksopen${mode}") {
                    lock.unlock()
                }
            } else {
                log.debug "$lock is currently Unlocked"
            }
        }

        if(message) {
            if (settings."locksopen${mode}") {
                message = "These locks were Locked when hub was changed to $mode mode, Unlocking them" + message
            } else {
                message = "These locks were Locked when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No locks found to check for locked when hub changed to $mode mode"
    }    

    // Check for garage doors left open
    if (settings."garagedoors${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoors${mode}") {
            if (garagedoor.currentValue("door") != "closed") {
                message += ", $garagedoor"
                if (settings."garagedoorsoff${mode}") {
                    garagedoor.close()
                }
            } else {
                log.debug "$garagedoor is currently Closed"
            }
        }

        if(message) {
            if (settings."garagedoorsoff${mode}") {
                message = "These doors were Open when hub was changed to $mode mode, Closing them" + message
            } else {
                message = "These doors were Open when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No garage doors found to check for open when hub changed to $mode mode"
    }    

    // Check for garage doors left closed
    if (settings."garagedoorsflip${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoorsflip${mode}") {
            if (garagedoor.currentValue("door") != "open") {
                message += ", $garagedoor"
                if (settings."garagedoorsopen${mode}") {
                    garagedoor.open()
                }
            } else {
                log.debug "$garagedoor is currently Open"
            }
        }

        if(message) {
            if (settings."garagedoorsopen${mode}") {
                message = "These doors were Closed when hub was changed to $mode mode, Opening them" + message
            } else {
                message = "These doors were Closed when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No garage doors found to check for closed when hub changed to $mode mode"
    }    

    // Check for shades left open
    if (settings."shades${mode}") {
        def message = ""
        for (shade in settings."shades${mode}") {
            if (shade.currentValue("windowShade") != "closed") {
                message += ", $shade"
                if (settings."shadesoff${mode}") {
                    shade.close()
                }
            } else {
                log.debug "$shade is currently Closed"
            }
        }

        if(message) {
            if (settings."shadesoff${mode}") {
                message = "These shades were Open when hub was changed to $mode mode, Closing them" + message
            } else {
                message = "These shades were Open when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No window shades found to check for open when hub changed to $mode mode"
    }    

    // Check for window shades left closed
    if (settings."shadesflip${mode}") {
        def message = ""
        for (shade in settings."shadesflip${mode}") {
            if (shade.currentValue("windowShade") != "open") {
                message += ", $shade"
                if (settings."shadeson${mode}") {
                    shade.open()
                }
            } else {
                log.debug "$shade is currently Open"
            }
        }

        if(message) {
            if (settings."shadeson${mode}") {
                message = "These shades were Closed when hub was changed to $mode mode, Opening them" + message
            } else {
                message = "These shades were Closed when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No window shades found to check for closed when hub changed to $mode mode"
    }    

    // Check for valves left open
    if (settings."valves${mode}") {
        def message = ""
        for (valve in settings."valves${mode}") {
            if (valve.currentValue("valve") == "open" || valve.currentValue("contact") == "open") { // ST doesn't use valve due to firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valvesoff${mode}") {
                    valve.close()
                }
            } else {
                log.debug "$valve is currently Closed"
            }
        }

        if(message) {
            if (settings."valvesoff${mode}") {
                message = "These valves were Open when hub was changed to $mode mode, Closing them" + message
            } else {
                message = "These valves were Open when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No valves found to check for open when hub changed to $mode mode"
    }    

    // Check for valves left closed
    if (settings."valvesflip${mode}") {
        def message = ""
        for (valve in settings."valvesflip${mode}") {
            if (valve.currentValue("valve") == "closed" || valve.currentValue("contact") == "closed") { // ST doesn't use valve firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valveson${mode}") {
                    valve.open()
                }
            } else {
                log.debug "$valve is currently Open"
            }
        }

        if(message) {
            if (settings."valveson${mode}") {
                message = "These valves were Closed when hub was changed to $mode mode, Opening them" + message
            } else {
                message = "These valves were Closed when hub was changed to $mode mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No valves found to check for closed when hub changed to $mode mode"
    }    
}

private sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private sendMessages(mode, message) {
    if (mode) {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, settings."recipients${mode}")
        } else {
            if (settings."notify${mode}") {
                sendPush message
            }

            if (settings."sms${mode}") {
                sendText(settings."sms${mode}", message)
            }
        }
    } else {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, recipients)
        } else {
            if (notify) {
                sendPush message
            }

            if (sms) {
                sendText(sms, message)
            }
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Open Door/Window/Switch/Lock Notification and Action on Mode Change"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = []
                for (mode in location.modes) {
                    caps.add(settings."doors${mode}")
                    caps.add(settings."doorsflip${mode}")
                    caps.add(settings."garagedoors${mode}")
                    caps.add(settings."garagedoorsflip${mode}")
                    caps.add(settings."locks${mode}")
                    caps.add(settings."locksflip${mode}")
                    caps.add(settings."switches${mode}")
                    caps.add(settings."switchesflip${mode}")
                    caps.add(settings."shades${mode}")
                    caps.add(settings."shadesflip${mode}")
                    caps.add(settings."valves${mode}")
                    caps.add(settings."valvesflip${mode}")
                }
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}
