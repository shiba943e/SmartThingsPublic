/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "02.03.00"
}

/**
* Attic Fan Smart Ventilation
* Automatically turns on and off the attic ventilation fan based on outside temperature, sunlight on roof (lux) and internal temperature
*
* Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
*
* Change Log:
* 2017-9-6 - (v02.03.00) Added support for expirations past midnight
* 2016-11-5 - Added support for automatic code update notifications and fixed an issue with sms
* 2016-5-19 - Fix bug in schedules
* 2016-5-15 - Notify use if timezone/location is missing in setup
* 2016-3-3 - Only turn off fan if it's currently on (save Z-wave commands)
* 2015-10-4 - Fixed a bug when A/C is not selected (optional)
* 2015-7-25 - Added support to turn on fan when HAVC/AC is on cool mode (for attic HVAC's)
* 2015-7-22 - Added support for selecting upto 3 schedules days of week/time to operate
* 2015-7-21 - Initial release
*
*/

definition(
    name: "Attic Fan Smart Ventilation",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Automatically turns on and off the attic ventilation fan based on outside temperature, sunlight on roof (lux) and internal temperature",
    category: "Green Living",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Developers/whole-house-fan.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Developers/whole-house-fan@2x.png"
)

preferences {
    section("Attic Fan Smart Ventilation v${clientVersion()}") {
    }

    section("Select the attic fan(s)"){
        input "fans", "capability.switch", title: "Fan(s)", multiple: true
    }
    section("Outside/Roof Condition"){
        input "otSensor", "capability.temperatureMeasurement", title: "Roof/Outside Temperature Sensor"
        input "sunlight", "capability.illuminanceMeasurement", title: "Sun Brightness Sensor"
    }
    section("Inside Conditions"){
        input "itSensor", "capability.temperatureMeasurement", title: "Indoor Temperature Sensor"
        input "tTemp", "decimal", title: "Indoor target temperature"
        paragraph "Use the Attic Fan to cool the Attic when the Attic HVAC/AC is on and in cool mode to make it more efficient"
        input "acSensor", "capability.thermostat", title: "Attic HVAC/AC (optional)", required: false
    }
    section("Select the fan operating schedules (optional)") {
        paragraph "Schedule A - Select the first operating schedule time and day of week"
        input "startTimeA", "time", title: "Start Time", required: false
        input "endTimeA", "time", title: "End Time", required: false
        input name: "dayOfWeekA",
            type: "enum",
            title: "Which day of the week?",
            required: false,
            multiple: true,
            options: [
                'All Week',
                'Monday to Friday',
                'Saturday & Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
                'Sunday'
            ],
            defaultValue: 'All Week'

        paragraph "Schedule B - Select the second operating schedule time and day of week"
        input "startTimeB", "time", title: "Start Time", required: false
        input "endTimeB", "time", title: "End Time", required: false
        input name: "dayOfWeekB",
            type: "enum",
            title: "Which day of the week?",
            required: false,
            multiple: true,
            options: [
                'All Week',
                'Monday to Friday',
                'Saturday & Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
                'Sunday'
            ],
            defaultValue: 'All Week'

        paragraph "Schedule C - Select the second operating schedule time and day of week"
        input "startTimeC", "time", title: "Start Time", required: false
        input "endTimeC", "time", title: "End Time", required: false
        input "dayOfWeekC", "enum",
            title: "Which day of the week?",
            required: false,
            multiple: true,
            options: [
                'All Week',
                'Monday to Friday',
                'Saturday & Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
                'Sunday'
            ],
            defaultValue: 'All Week'
    }
    section() {
        label title: "Assign a name for this SmartApp (optional)", required: false
        input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
    }
}

def installed()
{
    log.trace "Installed: $settings"
    initialize()
}

def updated()
{
    log.trace "Updated: $settings"
    unsubscribe()
    unschedule() // clear any pending timers
    initialize()
}

private initialize()
{
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

    subscribe(location, modeChangeHandler)
    subscribe(itSensor, "temperature", temperatureHandler)
    subscribe(acSensor, "thermostatOperatingState", acHandler)
    checkFan()
}

def acHandler(evt)
{
    log.debug "A/C operating state changed to $evt.value"
    checkFan() // turn on or off as required due to mode change
}

def modeChangeHandler(evt)
{
    log.debug "Mode changed to $evt.value, checking if fans need to be activated"
    checkFan()
}

def temperatureHandler(evt)
{
    log.debug "Temperature changed to $evt.value from $evt.displayName"
    checkFan()
}

def checkFan()
{
    // Conditions for activating attic fan
    // 1. Outside temperature is lower than internal temperature and internal temperature is higher than target temperature
    // 2. Outside lux is > 5000 (direct sunlight on the roof heating roof more than ambient temp) and internal temp is higher than target temperature
    def tempThreshold = 1.0
    def luxThreshold = 5000.0
    def oTemp = otSensor.currentTemperature
    def iTemp = itSensor.currentTemperature
    def oLux = sunlight.currentIlluminance
    def fanTurnedOn = false

    log.debug "Indoor temperature ${iTemp}, Target temp $tTemp, Outside temp ${oTemp}, Outside lux ${oLux}"

    if (((oTemp < iTemp) || (oLux >= luxThreshold)) && ((iTemp - tTemp) >= tempThreshold) && (checkSchedule("A") || checkSchedule("B") || checkSchedule("C"))) {
        log.info "Turning on fans $fans due to temperature or sunlight conditions"
        fans?.on()
        fanTurnedOn = true
    }
    else if ((acSensor?.currentThermostatOperatingState == "cooling")  && (checkSchedule("A") || checkSchedule("B") || checkSchedule("C"))){ // Check if we need to turn on the fan while the A/C is in cool mode
        log.info "Turnings on Fans $fans to keep A/C cooling efficient"
        fans?.on()
        fanTurnedOn = true
    }
    else {
        fans?.each { fan ->
            if (fan.currentValue("switch") == "on") {
                log.info "Turning off fan $fan"
                fan.off()
            } else {
                log.debug "Fan $fan is already switched off"
            }
        }
    }

    // Check if we need to schedule an fan off check due to an endTime, if the fan has been turned on
    if (fanTurnedOn) // initialize only if we have all configured and set schedule to checkFan on/off as required at end time
    {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            sendPush "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        }
        
        ('A'..'C').each { // Check each schedule for an endTime
            if (settings."endTime${it}" && settings."startTime${it}") {
                if (settings."endTime${it}" <= settings."startTime${it}") { // End time is next day
                    runOnce(timeToday(settings."endTime${it}", timeZone).next(), checkFan) // Get the time for tomorrow
                    log.debug "Setting fan check to turn off tomorrow at ${timeToday(settings."endTime${it}", timeZone).next()}"
                } else {
                    runOnce(timeToday(settings."endTime${it}", timeZone), checkFan)
                    log.debug "Setting fan check to turn off today at ${timeToday(settings."endTime${it}", timeZone)}"
                }
            }
        }
    }
}

private checkSchedule(def x) {
    log.debug("Checking operating schedule $x")

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone);
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK);
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.debug "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."startTime${x}" != null && settings."endTime${x}" != null) {
        def scheduledStart = timeToday(settings."startTime${x}", timeZone)
        def scheduledEnd = timeToday(settings."endTime${x}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.debug "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.debug "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.debug("Operating Start ${scheduledStart.format("EEE MMM dd yyyy HH:mm z", timeZone)}, End ${scheduledEnd.format("EEE MMM dd yyyy HH:mm z", timeZone)}")

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.info("Outside operating time schedule")
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.debug("Operating DOW(s): ${settings."dayOfWeek${x}"}")

    if(settings."dayOfWeek${x}" == null) {
        log.error "Invalid Day of week ${settings."dayOfWeek${x}"}"
    } else if(settings."dayOfWeek${x}".contains('All Week')) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Monday') || settings."dayOfWeek${x}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Tuesday') || settings."dayOfWeek${x}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Wednesday') || settings."dayOfWeek${x}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Thursday') || settings."dayOfWeek${x}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Friday') || settings."dayOfWeek${x}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Saturday') || settings."dayOfWeek${x}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."dayOfWeek${x}".contains('Sunday') || settings."dayOfWeek${x}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }


    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.info("Within operating schedule")
        return true
    }
    else {
        log.info("Outside operating schedule")
        return false
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Attic Fan Smart Ventilation"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ fans, otSensor, sunlight, itSensor, acSensor ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}