/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "01.01.00"
}

/**
* Schedule HVAC Fan
*
* Copyright RBoy Apps
* Redistribution of any changes or code is not allowed without permission
* Change log:
* 2017-5-26 - (v 01.01.00) Added support for automatic update notifications
* 2016-5-19 - If end time is after start time then assume the end time is next day
* 2016-5-15 - Notify use if timezone/location is missing in setup 
* 2015-6-17 - Fix for changes in ST Platform
* 2015-2-11 -> Initial code
*/
definition(
    name: "HVAC Thermostat Automatic Fan Scheduling",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Setup a schedule to turn your thermostat fan on and off",
    category: "Green Living",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@2x.png",
    iconX3Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@3x.png")

preferences {
    section("HVAC Thermostat Automatic Fan Scheduling v${clientVersion()}") {
    }

    section("Choose thermostat(s)") {
        input "thermostats", "capability.thermostat", multiple: true
    }

    section("Thermostat Fan Schedule") {
        paragraph "Set the durations for the fan to turn on and then turn off (in a cycle)"
        input "onDuration", "number", title: "Fan on duration (minutes)", description: "For how long should the fan run"
        input "offDuration", "number", title: "Fan off duration (minutes)", description: "For how long should the fan turn off"
        input "mode", "enum", title: "Fan mode", description: "Do you want to turn fan on or in Circulate mode (refer to your HVAC)", multiple: false, options: ['On','Circulate'], defaultValue: 'On'
    }

    section("Select the fan operating time and days (optional)") {
        input "startTime", "time", title: "Start Time", required: false
        input "endTime", "time", title: "End Time", required: false
        input "dayOfWeek", "enum",
            title: "Which day of the week?",
            required: false,
            multiple: true,
            options: [
                'All Week',
                'Monday to Friday',
                'Saturday & Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
                'Sunday'
            ],
            defaultValue: 'All Week'
    }

    section() {
        label title: "Assign a name for this SmartApp (optional)", required: false
        input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
    }
}

def installed() {
    log.debug "Installed with settings: ${settings}"

    initialize()
}

def updated() {
    log.debug "Updated with settings: ${settings}"

    unsubscribe()
    unschedule() // clear any pending timers
    initialize()
}

def initialize() {
    subscribe(location, modeChangeHandler)
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

    runIn(1, onHandler)
}

// Handle mode changes, reinitialize the timers after a mode change, this is to workaround the issue of the last timer firing while in a non running mode, resume operations when supported modes are set
def modeChangeHandler(evt) {
    log.debug "Reinitializing on mode change notification, new mode $evt.value"
    //sendNotificationEvent("$thermostats Reinitializing on mode change notification, new mode $evt.value")
    unschedule()
    runIn(1, onHandler)
}

def onHandler() {
    if (checkSchedule() == false) {
        log.debug "OnHandler called, outside configured schedule, not turning on fan, rechecking in 5 minutes"
        runIn(5 * 60, onHandler) // check back in 5 minutes
        return;
    }

    log.debug "OnHandler called, scheduling off in $onDuration minutes"
    runIn(onDuration * 60, offHandler) // setup off handler schedule

    if (mode == 'On') {
        log.debug "Turning fan to On mode for $thermostats"
        thermostats?.setThermostatFanMode("on")
    } else {
        log.debug "Turning fan to Circulate mode for $thermostats"
        thermostats?.setThermostatFanMode("circulate")
    }
}

def offHandler() {
    // Don't check schedule here, fan must always be turned off/auto mode (can't turn off really)
    log.debug "OffHandler called, scheduling on in $offDuration minutes"

    runIn(offDuration * 60, onHandler) // setup off handler schedule

    log.debug "Turning fan to Auto (off) mode for $thermostats"
    thermostats?.setThermostatFanMode("auto")
}

def checkSchedule() {
    log.debug("Checking operating schedule")

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone);
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK);
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.debug "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (startTime != null && endTime != null) {
        def scheduledStart = timeToday(startTime, timeZone)
        def scheduledEnd = timeToday(endTime, timeZone)
        
        if (scheduledEnd <= scheduledStart) { // End time is next day
            log.debug "End time is before start time, assuming it is the next day"
            scheduledEnd = scheduledEnd.next() // Get the time for tomorrow
        }

        log.debug("Operating Start ${scheduledStart.format("EEE MMM dd yyyy HH:mm z", timeZone)}, End ${scheduledEnd.format("EEE MMM dd yyyy HH:mm z", timeZone)}")

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.info("Outside operating time schedule")
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.debug("Operating DOW(s): $dayOfWeek")

    if(dayOfWeek.contains('All Week')) {
        doChange = true
    }
    else if((dayOfWeek.contains('Monday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Tuesday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Wednesday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Thursday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Friday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Saturday') || dayOfWeek.contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Sunday') || dayOfWeek.contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }


    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.info("Within operating schedule")
        return true
    }
    else {
        log.info("Outside operating schedule")
        return false
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "HVAC Thermostat Automatic Fan Scheduling"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ thermostats ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}