/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 

def clientVersion() {
    return "02.03.00"
}

/**
 * Intruder Alert with Alarms, Lights and Camera Pictures
 *
 * Author: SmartThings, updates by RBoy Apps
 * Changes Copyright RBoy Apps, redistribution of any changes or modified code is not allowed without permission
 * 2017-5-26 - (v02.03.00) Added support for automatic reseting of the app when no Alarm is used, disabled flashing lights, improved responsiveness
 * 2017-5-26 - (v02.02.00) Added notifications when all alarms are turned off when a single alarm is detected to be turned off, added support for multiple SMS number notifications by separating with a *
 * 2016-11-3 - Added support for tamper devices and for automatic code updates
 * 2016-10-22 - Empty/no delay time now sets it to immediate arming
 * 2016-8-31 - Fix for SMS not being sent, added support for arming notifications, improved system arming setup
 * 2016-8-17 - Added version and workaround for ST contact address book bug
 * 2016-2-22 - Include alarm source details when sending alarm notifications
 * 2016-1-17 - You can specify multiple sms phone numbers by putting a + to separate them
 * 2016-1-5 - Added support to set off alarm when a door is unlocked
 * 2015-11-27 - Added support to set dimmer levels to 100% while turning on the lights
 * 2015-2-15 - Bug fix for lights not coming on, change input to phone number for text message
 * 2015-2-2 - Added support for turning on lights/switches
 */
definition(
    name: "Intruder Alert with Alarms, Lights and Camera Pictures",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Alerts you when there are intruders and turns on lights/alarms but not when you just got up for a glass of water in the middle of the night",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-IsItSafe.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-IsItSafe@2x.png"
)

preferences {
    page(name: "mainPage")
}
def mainPage() {
    dynamicPage(name: "mainPage", title: "Intruder Alert with Alarms, Lights and Camera Pictures v${clientVersion()}", install: true, uninstall: true) {
        section("Devices detecting an intruder") {
            input "intrusionMotions", "capability.motionSensor", title: "Motion Sensors", multiple: true, required: false
            input "intrusionContacts", "capability.contactSensor", title: "Contact Sensors", multiple: true, required: false
            input "intrusionLocks", "capability.lock", title: "Door Locks", multiple: true, required: false
            input "tamperDevices", "capability.tamperAlert", title: "Tamper Devices", multiple: true, required: false
        }
        section("Sensors detecting residents") {
            input "residentMotions", "capability.motionSensor", title: "Motion Sensors", multiple: true, required: false
        }
        section("Alarm settings and actions") {
            input "alarms", "capability.alarm", title: "Which Alarm(s)", multiple: true, required: false, submitOnChange: true
            if (alarms) {
                input "seconds", "number", title: "Delay in seconds before siren sounds (optional)", required: false
                input "silent", "enum", options: ["Yes","No"], title: "Flash alarm lights only (if supported)", required: true
            }
            input "cameras", "capability.imageCapture", title: "Which Cameras(s) to take pictures", multiple: true, required: false
            input "lightson", "capability.switch", title: "Turn on these lights", multiple: true, required: false
            //input "lightsFlashing", "capability.switch", title: "Flash these lights", multiple: true, required: false // Flashing doesn't work reliably with the z-wave/zigbee mesh yet
        }
        section("Notifications") {
            input "textMessage", "text", title: "Send this message (optional)", multiple: false, required: false
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                input "sms", "phone", title: "To this phone", multiple: false, required: false
            }
            paragraph "Enable this option to get more detailed notifications like arming estimate"
            input "armNotifications", "bool", title: "Get detailed notifications", required: false
        }
        section("Arm system after residents are quiet") {
            input "residentsQuietThreshold", "number", title: "Delay arming time (minutes)", required: false
        }
        section("Operating Modes") {
            mode title: "Enable system only when in this mode(s)", required: true, multiple: true // We need a mode since it can't be active for all modes
        }
        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def installed() {
	log.debug "INSTALLED with $settings"
	subscribeToEvents()
}

def updated() {
	log.debug "UPDATED with $settings"
	subscribeToEvents()
}

private subscribeToEvents()
{
	unschedule()
	unsubscribe()
	alarms?.off() // Reset any alarms

    state.alarmActive = false
	state.residentsAreUp = false
    state.armNotification = false
	state.lastArmRequest = null

    subscribe(intrusionMotions, "motion", intruderMotion)
	subscribe(intrusionContacts, "contact", contact)
	subscribe(intrusionLocks, "lock", door)
	subscribe(alarms, "alarm", alarm)
    subscribe(tamperDevices, "tamper", tamper)
    subscribe(location, "mode", modeChangeHandler)
	subscribe(app, appTouch)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def modeChangeHandler(evt) {
    log.trace "Mode change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking"}"
    scheduleReArmCheck()
}

def appTouch(evt)
{
    log.info "Resetting alarms and rearming system"
	subscribeToEvents()
}

def tamper(evt)
{
    if (evt.value == "detected") {
		log.trace "Tamper $evt.displayName by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			} else {
				disarmIntrusionDetection()
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}    
}

def intruderMotion(evt)
{
	if (evt.value == "active") {
		log.trace "$evt.displayName motion by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			} else {
				disarmIntrusionDetection()
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}
}

def contact(evt)
{
	if (evt.value == "open") {
		log.trace "Contact $evt.displayName opened by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			} else {
				disarmIntrusionDetection()
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}
}

def door(evt)
{
    if (evt.value == "unlocked") {
		log.trace "Door $evt.displayName unlocked by potential intruder, residentsAreUp: $state.residentsAreUp"
        if (!state.residentsAreUp) {
            if (residentsHaveBeenQuiet()) {
                startAlarmSequence(evt)
            } else {
                disarmIntrusionDetection()
            }
        } else {
            log.trace "Residents are up, ignoring"
        }
    }
}

def alarm(evt)
{
	log.trace "Alarm $evt.name: $evt.value"
	if (evt.value == "off") { // If any one alarm is turned off, turn off the rest
		alarms?.off()
		state.alarmActive = false

        if (location.contactBookEnabled) {
            sendNotificationToContacts("$evt.displayName: Alarm turned off, turning off all other alarms", recipients)
        } else {
            sendPush("$evt.displayName: Alarm turned off, turning off all other alarms")
            if (sms) {
                sendText(sms, "$evt.displayName: Alarm turned off, turning off all other alarms")
            }
        }
    }
}

private residentsHaveBeenQuiet()
{
	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	def result = true
	def t0 = new Date(now() - threshold)
	for (sensor in residentMotions) {
		def recentStates = sensor.statesSince("motion", t0)
		if (recentStates.find{it.value == "active"}) {
			result = false
			break
		}
	}
	log.trace "residentsHaveBeenQuiet: $result"
	result
}

private disarmIntrusionDetection()
{
	log.trace "Residents are up, disarming intrusion detection"
	state.residentsAreUp = true
	scheduleReArmCheck()
}

private scheduleReArmCheck()
{
    state.armNotification = false // Reset each time we start a rearm
	state.lastArmRequest = now()
	def cron = "0 0/1 * * * ?" // Check every 1 minute
	schedule(cron, "checkForReArm")
	log.trace "Starting re-arm check, cron: $cron"
    checkForReArm()
}

def checkForReArm()
{
	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	// check last intruder motion
	def lastIntruderMotion = state.lastArmRequest
	log.trace "checkForReArm: lastArmRequest=${lastIntruderMotion/1000} seconds"
	if (lastIntruderMotion != null)
	{
		log.debug "checkForReArm, time since last arm request: ${(now() - lastIntruderMotion)/(1000)} seconds, threshold is ${threshold/1000} seconds"
		if (now() - lastIntruderMotion > threshold) {
            def msg = "Arming Intruder Alert System"
            if (armNotifications) {
                msg += " for ${location.mode} mode"
            }
			log.debug msg
            sendPush(msg)
			state.residentsAreUp = false
            state.armNotification = false
			unschedule(checkForReArm)
		} else {
            if (!state.armNotification) {
                state.armNotification = true // We've sent a notification
                def timeToArm = ((now() - lastIntruderMotion + threshold)/(60*1000)) as Float
                log.trace "Time to arm: $timeToArm minutes"
                if (timeToArm < 1) { // If we have less than a minute then show it as 1 minute since the scheduler it setup for 1 minute checks
                    timeToArm = 1
                }
                def msg = "Arming Intruder Alert System in about ${timeToArm.round()} minutes"
                log.debug msg
                if (armNotifications) {
                    sendPush(msg)
                }
            }
        }
	} else {
		log.warn "checkForReArm: lastIntruderMotion was null, unable to check for re-arming intrusion detection"
	}	
}

private startAlarmSequence(evt)
{
	if (state.alarmActive) {
		log.trace "Alarm already active"
	} else {
		log.trace "Starting intruder actions sequence"

        // Only set this if we have Alarms defined because it will be reset when the alarms are turned off, without alarms start sequence every time
        if (alarms) {
            state.alarmActive = true
            if (silent == "Yes") {
                log.debug "Silent alarm only"
                alarms?.strobe()
            } else {
                def delayTime = seconds
                if (delayTime) {
                    alarms?.strobe()
                    runIn(delayTime, "soundSiren")
                    log.trace "Sounding siren in $delayTime seconds"
                } else {
                    soundSiren()
                }
            }
        }

		if (lightsFlashing) {
			log.debug "Flashing lights"
			runIn(1, "continueFlashing") // do it offline to avoid timeout since it's a heavy activity
		}
        
        if (lightson) {
        	log.debug "Turning on lights $lightson"
        	lightson?.on()
            lightson?.each { lighton -> 
                if (lighton?.hasCommand("setLevel")) {
                    lighton?.setLevel(100) // If it is a dimmer set it to 100%
                }
            }
        }

        if (cameras) {
        	log.debug "Taking pictures with $cameras"
        	cameras?.take()
        }

        // Do this in the end because it can timeout
        if (location.contactBookEnabled) {
            sendNotificationToContacts(textMessage ? "$evt.displayName: $textMessage" : "$evt.displayName: Potential intruder detected", recipients)
        } else {
            sendPush(textMessage ? "$evt.displayName: $textMessage" : "$evt.displayName: Potential intruder detected")
            if (sms) {
                sendText(sms, textMessage ? "$evt.displayName: $textMessage" : "$evt.displayName: Potential intruder detected")
            }
        }
    }
}

def soundSiren()
{
	if (state.alarmActive) {
		log.debug "Sounding siren"
		alarms?.both()
	} else {
		log.debug "Intruder notification reset, alarm activation aborted"
	}
}

def continueFlashing()
{
    // Flash 10 times
    state.flashingCount = (state.flashingCount ?: 0) + 1
    if (state.flashingCount <= 10) {
        flashLights(1000)
        runIn(2, "continueFlashing") // After 2 seconds because we're turning off after 1 second
        log.trace "Flashing lights counter: $state.flashingCount"
    } else {
        state.flashingCount = 0 // Reset it
        log.trace "Finished flashing"
    }
}

private flashLights(long delay) {
    lightsFlashing?.on()
    lightsFlashing?.off([delay: delay])
}

private sendText(number, message) {
	if (number) {
    	def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Intruder Alert with Alarms, Lights and Camera Pictures"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = 
                [ intrusionMotions,
                 intrusionContacts,
                 intrusionLocks,
                 tamperDevices,
                 residentMotions,
                 alarms,
                 cameras,
                 lightson,
                 lightsFlashing ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}